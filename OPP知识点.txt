
1: 继承中有两个概念: 1.覆盖(override) 2.隐藏(new)
	1.1: 覆盖就是重写基类的虚方法(virtual/abstract),实现多态性 
	1.2: 隐藏就是没有重写基类的同名虚方法，只是单纯的隐藏/屏蔽掉,没有多态性

2: 基类需要重写的虚方法需要加virtual,派生类需要加override,如果没加override就不是重写基类的方法，而是同名的函数会隐藏基类的方法

3: 1.兄弟类不可以转换，2.不可以把基类赋值给派生类，虽然IDE语法没有报错，但是运行时是错误的(不可以逆变) 3.只能是派生类赋值基类，实现多态性
	3.1: 
		Child1 child1 = new Child1();
		Child2 child2 = (Child2)child1; //错误
	3.2:
		Child1 child1 = new Fathor(); //IDE语法没有报错,其实是不可以的
	3.3:
		Fathor child = new Child1();	

4: 当派生类赋值给基类时，可以实现多态性，但是有一个要注意的是：只能看到基类的字段/属性/方法，而不能看到派生类的
	4.1:
		Fathor child = new Child();
		child.fathorValue; //可以看到Fathor类的字段
		child.childValue; //错误的，不可以看到Child的字段，虽然child对象是Child的实例隐式转换而来的
		child.virtualFunc(); //这里调用虚方法实现多态性
		//这里显示转换回派生类，才可以使用派生类的成员
		Child obj = (Child)child;
		obj.childValue;
	4.2: 总结: 派生类实例隐式转换到基类，这个实例就是相当于基类的对象实例了，是看不到派生类的字段与方法,当调用虚方法时实现
	     多态性,如果想调用派生类的成员必须显示转换回去。

5. 派生类中的字段如果与基类的同名，只能是隐藏/屏蔽。无法像方法那样可以重写基类的虚方法,属性如果用abstract修饰的话,一定要在派生类中override覆盖重写的

6. 多态性: "一个接口,多个功能"
	1.静态多态性(在编译时发生的):函数重载,运算符重载
	2.动态多态性(运行时发生的)

7.自我叙述: 
	1.为什么要有封装：用类把同一功能元素统一起来，用访问修饰符(public,private,protected)限制元素不被乱使用，整个结构清晰
	2.继承：代码的重用性(在物理上会不会节省内存?目前不太清楚)
	3.多态性: 